
> web222-assignment-1@6.0.0 test
> jest --

jest-haste-map: Haste module naming collision: web222-assignment-1
  The following files share their name; please adjust your hasteImpl:
    * <rootDir>\package.json
    * <rootDir>\submission\package.json

FAIL src/problem-04.test.js
  ● Problem 4 - toDateString() function › a date is correctly converted to a date string in the YYYY/MM/DD format

    expect(received).toBe(expected) // Object.is equality

    Expected: "2023/12/10"
    Received: undefined

      14 |     let date = new Date('December 10, 2023');
      15 |     let result = toDateString(date, 'YYYY/MM/DD');
    > 16 |     expect(result).toBe('2023/12/10');
         |                    ^
      17 |   });
      18 |
      19 |   test('a date is correctly converted to a date string in the DD/MM/YYYY format', function () {

      at Object.toBe (src/problem-04.test.js:16:20)

  ● Problem 4 - toDateString() function › a date is correctly converted to a date string in the DD/MM/YYYY format

    expect(received).toBe(expected) // Object.is equality

    Expected: "10/12/2023"
    Received: undefined

      20 |     let date = new Date('December 10, 2023');
      21 |     let result = toDateString(date, 'DD/MM/YYYY');
    > 22 |     expect(result).toBe('10/12/2023');
         |                    ^
      23 |   });
      24 |
      25 |   test('a date is correctly converted to a date string in the MM/DD/YYYY format', function () {

      at Object.toBe (src/problem-04.test.js:22:20)

  ● Problem 4 - toDateString() function › a date is correctly converted to a date string in the MM/DD/YYYY format

    expect(received).toBe(expected) // Object.is equality

    Expected: "12/10/2023"
    Received: undefined

      26 |     let date = new Date('December 10, 2023');
      27 |     let result = toDateString(date, 'MM/DD/YYYY');
    > 28 |     expect(result).toBe('12/10/2023');
         |                    ^
      29 |   });
      30 |
      31 |   test('an error is thrown if the format is unknown', function () {

      at Object.toBe (src/problem-04.test.js:28:20)

  ● Problem 4 - toDateString() function › an error is thrown if the format is unknown

    expect(received).toThrow()

    Received function did not throw

      31 |   test('an error is thrown if the format is unknown', function () {
      32 |     let date = new Date('December 10, 2023');
    > 33 |     expect(() => toDateString(date, 'M/D/Y')).toThrow();
         |                                               ^
      34 |   });
      35 |
      36 |   test('a date is correctly converted to a date string with expected month and day', function () {

      at Object.toThrow (src/problem-04.test.js:33:47)

  ● Problem 4 - toDateString() function › a date is correctly converted to a date string with expected month and day

    expect(received).toBe(expected) // Object.is equality

    Expected: "2023/12/17"
    Received: undefined

      37 |     let date = new Date('December 17, 2023');
      38 |     let result = toDateString(date, 'YYYY/MM/DD');
    > 39 |     expect(result).toBe('2023/12/17');
         |                    ^
      40 |   });
      41 |
      42 |   test('a date is correctly converted to a date string, with padded month', function () {

      at Object.toBe (src/problem-04.test.js:39:20)

  ● Problem 4 - toDateString() function › a date is correctly converted to a date string, with padded month

    expect(received).toBe(expected) // Object.is equality

    Expected: "2023/01/10"
    Received: undefined

      43 |     let date = new Date('January 10, 2023');
      44 |     let result = toDateString(date, 'YYYY/MM/DD');
    > 45 |     expect(result).toBe('2023/01/10');
         |                    ^
      46 |   });
      47 |
      48 |   test('a date is correctly converted to a date string, with padded day', function () {

      at Object.toBe (src/problem-04.test.js:45:20)

  ● Problem 4 - toDateString() function › a date is correctly converted to a date string, with padded day

    expect(received).toBe(expected) // Object.is equality

    Expected: "2023/12/01"
    Received: undefined

      49 |     let date = new Date('December 01, 2023');
      50 |     let result = toDateString(date, 'YYYY/MM/DD');
    > 51 |     expect(result).toBe('2023/12/01');
         |                    ^
      52 |   });
      53 |
      54 |   test('toDateString and parseDateString are reversible', function () {

      at Object.toBe (src/problem-04.test.js:51:20)

  ● Problem 4 - toDateString() function › toDateString and parseDateString are reversible

    TypeError: Cannot read properties of undefined (reading 'getFullYear')

      4 | function compareDates(a, b) {
      5 |   return (
    > 6 |     a.getFullYear() === b.getFullYear() &&
        |       ^
      7 |     a.getMonth() === b.getMonth() &&
      8 |     a.getDate() === b.getDate()
      9 |   );

      at getFullYear (src/problem-04.test.js:6:7)
      at Object.compareDates (src/problem-04.test.js:58:12)

  ● Problem 4 - toDateString() function › an invalid date causes an error to be thrown

    expect(received).toThrow()

    Received function did not throw

      61 |
      62 |   test('an invalid date causes an error to be thrown', function () {
    > 63 |     expect(() => toDateString('invalid date')).toThrow();
         |                                                ^
      64 |   });
      65 | });
      66 |

      at Object.toThrow (src/problem-04.test.js:63:48)

FAIL src/problem-02.test.js
  ● Problem 2 - createLinkTag() function › correct <link> tag for stylesheet link, stripping double-quotes where appropriate

    expect(received).toBe(expected) // Object.is equality

    Expected: "<link rel=stylesheet href=styles.css>"
    Received: undefined

       6 |     let href = 'styles.css';
       7 |     let result = createLinkTag(rel, href);
    >  8 |     expect(result).toBe('<link rel=stylesheet href=styles.css>');
         |                    ^
       9 |   });
      10 |
      11 |   test('leading whitespace is removed before using values', function () {

      at Object.toBe (src/problem-02.test.js:8:20)

  ● Problem 2 - createLinkTag() function › leading whitespace is removed before using values

    expect(received).toBe(expected) // Object.is equality

    Expected: "<link rel=stylesheet href=styles.css>"
    Received: undefined

      13 |     let href = '                  styles.css';
      14 |     let result = createLinkTag(rel, href);
    > 15 |     expect(result).toBe('<link rel=stylesheet href=styles.css>');
         |                    ^
      16 |   });
      17 |
      18 |   test('trailing whitespace is removed before using values', function () {

      at Object.toBe (src/problem-02.test.js:15:20)

  ● Problem 2 - createLinkTag() function › trailing whitespace is removed before using values

    expect(received).toBe(expected) // Object.is equality

    Expected: "<link rel=stylesheet href=styles.css>"
    Received: undefined

      20 |     let href = 'styles.css                             ';
      21 |     let result = createLinkTag(rel, href);
    > 22 |     expect(result).toBe('<link rel=stylesheet href=styles.css>');
         |                    ^
      23 |   });
      24 |
      25 |   test('double-quotes around value are not optional when the value includes a space', function () {

      at Object.toBe (src/problem-02.test.js:22:20)

  ● Problem 2 - createLinkTag() function › double-quotes around value are not optional when the value includes a space

    expect(received).toBe(expected) // Object.is equality

    Expected: "<link rel=\"rel with space\" href=\"href with space\">"
    Received: undefined

      27 |     let href = 'href with space';
      28 |     let result = createLinkTag(rel, href);
    > 29 |     expect(result).toBe('<link rel="rel with space" href="href with space">');
         |                    ^
      30 |   });
      31 |
      32 |   test('double-quotes around value are not optional when the value includes tab', function () {

      at Object.toBe (src/problem-02.test.js:29:20)

  ● Problem 2 - createLinkTag() function › double-quotes around value are not optional when the value includes tab

    expect(received).toBe(expected) // Object.is equality

    Expected: "<link rel=\"rel	with	tab\" href=\"href	with	tab\">"
    Received: undefined

      34 |     let href = 'href\twith\ttab\t';
      35 |     let result = createLinkTag(rel, href);
    > 36 |     expect(result).toBe('<link rel="rel\twith\ttab" href="href\twith\ttab">');
         |                    ^
      37 |   });
      38 | });
      39 |

      at Object.toBe (src/problem-02.test.js:36:20)

FAIL src/problem-08.test.js
  ● Problem 8 - buildApiEndpoint() function › correct values produce an expected endpoint

    expect(received).toEqual(expected) // deep equality

    Expected: "/users/123/John%20Doe"
    Received: undefined

      4 |   test('correct values produce an expected endpoint', function () {
      5 |     let endpoint = buildApiEndpoint('users', '123', 'John Doe');
    > 6 |     expect(endpoint).toEqual('/users/123/John%20Doe');
        |                      ^
      7 |   });
      8 |
      9 |   test('extraData values are properly encoded in endpoint', function () {

      at Object.toEqual (src/problem-08.test.js:6:22)

  ● Problem 8 - buildApiEndpoint() function › extraData values are properly encoded in endpoint

    expect(received).toEqual(expected) // deep equality

    Expected: "/products/456/Special%3A%20Limited%20Edition"
    Received: undefined

       9 |   test('extraData values are properly encoded in endpoint', function () {
      10 |     let endpoint = buildApiEndpoint('products', '456', 'Special: Limited Edition');
    > 11 |     expect(endpoint).toEqual('/products/456/Special%3A%20Limited%20Edition');
         |                      ^
      12 |   });
      13 |
      14 |   test('extraData is optional', function () {

      at Object.toEqual (src/problem-08.test.js:11:22)

  ● Problem 8 - buildApiEndpoint() function › extraData is optional

    expect(received).toEqual(expected) // deep equality

    Expected: "/users/123"
    Received: undefined

      14 |   test('extraData is optional', function () {
      15 |     let endpoint = buildApiEndpoint('users', '123');
    > 16 |     expect(endpoint).toEqual('/users/123');
         |                      ^
      17 |   });
      18 |
      19 |   test('missing or empty resourceType or resourceId throw', function () {

      at Object.toEqual (src/problem-08.test.js:16:22)

  ● Problem 8 - buildApiEndpoint() function › missing or empty resourceType or resourceId throw

    expect(received).toThrow()

    Received function did not throw

      18 |
      19 |   test('missing or empty resourceType or resourceId throw', function () {
    > 20 |     expect(() => buildApiEndpoint()).toThrow();
         |                                      ^
      21 |     expect(() => buildApiEndpoint('users')).toThrow();
      22 |     expect(() => buildApiEndpoint('', '123', 'John Doe')).toThrow();
      23 |     expect(() => buildApiEndpoint('users', '', 'John Doe')).toThrow();

      at Object.toThrow (src/problem-08.test.js:20:38)

  ● Problem 8 - buildApiEndpoint() function › extraData can be left out

    expect(received).toEqual(expected) // deep equality

    Expected: "/users/123"
    Received: undefined

      27 |   test('extraData can be left out', function () {
      28 |     let endpoint = buildApiEndpoint('users', '123');
    > 29 |     expect(endpoint).toEqual('/users/123');
         |                      ^
      30 |   });
      31 |
      32 |   test('resourceId can be a number', function () {

      at Object.toEqual (src/problem-08.test.js:29:22)

  ● Problem 8 - buildApiEndpoint() function › resourceId can be a number

    expect(received).toEqual(expected) // deep equality

    Expected: "/users/123/John%20Doe"
    Received: undefined

      32 |   test('resourceId can be a number', function () {
      33 |     let endpoint = buildApiEndpoint('users', 123, 'John Doe');
    > 34 |     expect(endpoint).toEqual('/users/123/John%20Doe');
         |                      ^
      35 |   });
      36 |
      37 |   test('resourceId can be a string containing a number', function () {

      at Object.toEqual (src/problem-08.test.js:34:22)

  ● Problem 8 - buildApiEndpoint() function › resourceId can be a string containing a number

    expect(received).toEqual(expected) // deep equality

    Expected: "/users/123/John%20Doe"
    Received: undefined

      37 |   test('resourceId can be a string containing a number', function () {
      38 |     let endpoint = buildApiEndpoint('users', '123', 'John Doe');
    > 39 |     expect(endpoint).toEqual('/users/123/John%20Doe');
         |                      ^
      40 |   });
      41 | });
      42 |

      at Object.toEqual (src/problem-08.test.js:39:22)

FAIL src/problem-05.test.js
  ● Problem 5 - normalizeTime() function › a valid time in the form h:m:s AM/PM is returned as expected

    expect(received).toBe(expected) // Object.is equality

    Expected: "(13, 30, 0)"
    Received: undefined

      20 |   test('a valid time in the form h:m:s AM/PM is returned as expected', function () {
      21 |     let time = '01:30:00 PM';
    > 22 |     expect(normalizeTime(time)).toBe('(13, 30, 0)');
         |                                 ^
      23 |   });
      24 |
      25 |   test('a valid time in the form H:M:S is returned as expected', function () {

      at Object.toBe (src/problem-05.test.js:22:33)

  ● Problem 5 - normalizeTime() function › a valid time in the form H:M:S is returned as expected

    expect(received).toBe(expected) // Object.is equality

    Expected: "(13, 30, 0)"
    Received: undefined

      25 |   test('a valid time in the form H:M:S is returned as expected', function () {
      26 |     let time = '13:30:00';
    > 27 |     expect(normalizeTime(time)).toBe('(13, 30, 0)');
         |                                 ^
      28 |   });
      29 |
      30 |   test('an invalid time in the form h:m:s AM/PM is returned as null', function () {

      at Object.toBe (src/problem-05.test.js:27:33)

  ● Problem 5 - normalizeTime() function › an invalid time in the form h:m:s AM/PM is returned as null

    expect(received).toBe(expected) // Object.is equality

    Expected: null
    Received: undefined

      30 |   test('an invalid time in the form h:m:s AM/PM is returned as null', function () {
      31 |     let time = '13:30:00 PM';
    > 32 |     expect(normalizeTime(time)).toBe(null);
         |                                 ^
      33 |   });
      34 |
      35 |   test('an invalid time in the form H:M:S is returned as null', function () {

      at Object.toBe (src/problem-05.test.js:32:33)

  ● Problem 5 - normalizeTime() function › an invalid time in the form H:M:S is returned as null

    expect(received).toBe(expected) // Object.is equality

    Expected: null
    Received: undefined

      35 |   test('an invalid time in the form H:M:S is returned as null', function () {
      36 |     let time = '24:30:00';
    > 37 |     expect(normalizeTime(time)).toBe(null);
         |                                 ^
      38 |   });
      39 |
      40 |   test('a time with invalid minute value is returned as null', function () {

      at Object.toBe (src/problem-05.test.js:37:33)

  ● Problem 5 - normalizeTime() function › a time with invalid minute value is returned as null

    expect(received).toBe(expected) // Object.is equality

    Expected: null
    Received: undefined

      40 |   test('a time with invalid minute value is returned as null', function () {
      41 |     let time = '01:60:00 PM';
    > 42 |     expect(normalizeTime(time)).toBe(null);
         |                                 ^
      43 |     time = '13:60:00';
      44 |     expect(normalizeTime(time)).toBe(null);
      45 |   });

      at Object.toBe (src/problem-05.test.js:42:33)

  ● Problem 5 - normalizeTime() function › a time with invalid second value is returned as null

    expect(received).toBe(expected) // Object.is equality

    Expected: null
    Received: undefined

      47 |   test('a time with invalid second value is returned as null', function () {
      48 |     let time = '01:30:60 PM';
    > 49 |     expect(normalizeTime(time)).toBe(null);
         |                                 ^
      50 |     time = '13:30:60';
      51 |     expect(normalizeTime(time)).toBe(null);
      52 |   });

      at Object.toBe (src/problem-05.test.js:49:33)

FAIL src/problem-03.test.js
  ● Problem 3 - parseDateString() function › not passing a date string throws an Error

    expect(received).toThrow()

    Received function did not throw

       9 |   test('not passing a date string throws an Error', function () {
      10 |     // null
    > 11 |     expect(() => parseDateString(null)).toThrow();
         |                                         ^
      12 |     // undefined
      13 |     expect(() => parseDateString()).toThrow();
      14 |     // empty string

      at Object.toThrow (src/problem-03.test.js:11:41)

  ● Problem 3 - parseDateString() function › passing an invalid date string format throws an Error

    expect(received).toThrow()

    Received function did not throw

      18 |   test('passing an invalid date string format throws an Error', function () {
      19 |     // 2-digit year
    > 20 |     expect(() => parseDateString('20/03/12')).toThrow();
         |                                               ^
      21 |     // 1-digit month
      22 |     expect(() => parseDateString('2020/3/12')).toThrow();
      23 |     // using spaces vs. slashes

      at Object.toThrow (src/problem-03.test.js:20:47)

  ● Problem 3 - parseDateString() function › thrown error uses a proper Error object and message

    expect(received).toThrow(expected)

    Expected message: "invalid date string, expected a `YYYY/MM/DD` or `DD/MM/YYYY` formatted string"

    Received function did not throw

      32 |     const message = 'invalid date string, expected a `YYYY/MM/DD` or `DD/MM/YYYY` formatted string';
      33 |     const error = new Error(message);
    > 34 |     expect(() => parseDateString()).toThrow(error);
         |                                     ^
      35 |   });
      36 |
      37 |   test('passing a valid YYYY/MM/DD date string results in correct date object', function () {

      at Object.toThrow (src/problem-03.test.js:34:37)

  ● Problem 3 - parseDateString() function › passing a valid YYYY/MM/DD date string results in correct date object

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: undefined

      37 |   test('passing a valid YYYY/MM/DD date string results in correct date object', function () {
      38 |     let result = parseDateString('2023/01/15');
    > 39 |     expect(assertDate(result, 2023, 1, 15)).toBe(true);
         |                                             ^
      40 |   });
      41 |
      42 |   test('passing a valid DD/MM/YYYY date string results in correct date object', function () {

      at Object.toBe (src/problem-03.test.js:39:45)

  ● Problem 3 - parseDateString() function › passing a valid DD/MM/YYYY date string results in correct date object

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: undefined

      42 |   test('passing a valid DD/MM/YYYY date string results in correct date object', function () {
      43 |     let result = parseDateString('15/01/2023');
    > 44 |     expect(assertDate(result, 2023, 1, 15)).toBe(true);
         |                                             ^
      45 |   });
      46 | });
      47 |

      at Object.toBe (src/problem-03.test.js:44:45)

FAIL src/problem-01.test.js
  ● Problem 1 - toCamelCase() function › returns name unmodified if it needs no changes

    expect(received).toBe(expected) // Object.is equality

    Expected: "variable"
    Received: undefined

      4 |   test('returns name unmodified if it needs no changes', function () {
      5 |     let result = toCamelCase('variable');
    > 6 |     expect(result).toBe('variable');
        |                    ^
      7 |   });
      8 |
      9 |   test('returns simple name in UpperCamelCase if requested', function () {

      at Object.toBe (src/problem-01.test.js:6:20)

  ● Problem 1 - toCamelCase() function › returns simple name in UpperCamelCase if requested

    expect(received).toBe(expected) // Object.is equality

    Expected: "Variable"
    Received: undefined

       9 |   test('returns simple name in UpperCamelCase if requested', function () {
      10 |     let result = toCamelCase('variable', true);
    > 11 |     expect(result).toBe('Variable');
         |                    ^
      12 |   });
      13 |
      14 |   test('correctly converts variable-name to variableName', function () {

      at Object.toBe (src/problem-01.test.js:11:20)

  ● Problem 1 - toCamelCase() function › correctly converts variable-name to variableName

    expect(received).toBe(expected) // Object.is equality

    Expected: "variableName"
    Received: undefined

      14 |   test('correctly converts variable-name to variableName', function () {
      15 |     let result = toCamelCase('variable-name');
    > 16 |     expect(result).toBe('variableName');
         |                    ^
      17 |   });
      18 |
      19 |   test('correctly converts variable-name to VariableName', function () {

      at Object.toBe (src/problem-01.test.js:16:20)

  ● Problem 1 - toCamelCase() function › correctly converts variable-name to VariableName

    expect(received).toBe(expected) // Object.is equality

    Expected: "VariableName"
    Received: undefined

      19 |   test('correctly converts variable-name to VariableName', function () {
      20 |     let result = toCamelCase('variable-name', true);
    > 21 |     expect(result).toBe('VariableName');
         |                    ^
      22 |   });
      23 |
      24 |   test('correctly deals with long kebab-case names', function () {

      at Object.toBe (src/problem-01.test.js:21:20)

  ● Problem 1 - toCamelCase() function › correctly deals with long kebab-case names

    expect(received).toBe(expected) // Object.is equality

    Expected: "variableNameWithManyDashes"
    Received: undefined

      24 |   test('correctly deals with long kebab-case names', function () {
      25 |     let result = toCamelCase('variable-name-with-many-dashes');
    > 26 |     expect(result).toBe('variableNameWithManyDashes');
         |                    ^
      27 |   });
      28 |
      29 |   test('correctly deals with multiple - in a row', function () {

      at Object.toBe (src/problem-01.test.js:26:20)

  ● Problem 1 - toCamelCase() function › correctly deals with multiple - in a row

    expect(received).toBe(expected) // Object.is equality

    Expected: "variableNameWithMultipleDashes"
    Received: undefined

      29 |   test('correctly deals with multiple - in a row', function () {
      30 |     let result = toCamelCase('variable---name-with-multiple-------------dashes');
    > 31 |     expect(result).toBe('variableNameWithMultipleDashes');
         |                    ^
      32 |   });
      33 | });
      34 |

      at Object.toBe (src/problem-01.test.js:31:20)

FAIL src/problem-06.test.js
  ● Problem 6 - formatTimes() › a single time is valid

    expect(received).toBe(expected) // Object.is equality

    Expected: "[(16, 26, 24)]"
    Received: undefined

      4 |   test('a single time is valid', function () {
      5 |     let result = formatTimes('4:26:24 PM');
    > 6 |     expect(result).toBe('[(16, 26, 24)]');
        |                    ^
      7 |   });
      8 |
      9 |   test('valid times of the form h:m:s should be formatted correctly in a list', function () {

      at Object.toBe (src/problem-06.test.js:6:20)

  ● Problem 6 - formatTimes() › valid times of the form h:m:s should be formatted correctly in a list

    expect(received).toBe(expected) // Object.is equality

    Expected: "[(1, 16, 24), (1, 16, 25), (1, 16, 26)]"
    Received: undefined

       9 |   test('valid times of the form h:m:s should be formatted correctly in a list', function () {
      10 |     let result = formatTimes('1:16:24', '1:16:25', '1:16:26');
    > 11 |     expect(result).toBe('[(1, 16, 24), (1, 16, 25), (1, 16, 26)]');
         |                    ^
      12 |   });
      13 |
      14 |   test('valid times of the form h:m:s AM/PM should be formatted correctly in a list', function () {

      at Object.toBe (src/problem-06.test.js:11:20)

  ● Problem 6 - formatTimes() › valid times of the form h:m:s AM/PM should be formatted correctly in a list

    expect(received).toBe(expected) // Object.is equality

    Expected: "[(16, 16, 24), (4, 16, 25)]"
    Received: undefined

      14 |   test('valid times of the form h:m:s AM/PM should be formatted correctly in a list', function () {
      15 |     let result = formatTimes('4:16:24 PM', '4:16:25 AM');
    > 16 |     expect(result).toBe('[(16, 16, 24), (4, 16, 25)]');
         |                    ^
      17 |   });
      18 |
      19 |   test('invalid times are skipped', function () {

      at Object.toBe (src/problem-06.test.js:16:20)

  ● Problem 6 - formatTimes() › invalid times are skipped

    expect(received).toBe(expected) // Object.is equality

    Expected: "[(4, 16, 24), (4, 16, 25)]"
    Received: undefined

      19 |   test('invalid times are skipped', function () {
      20 |     let result = formatTimes('4:16:24', '60:60:60', '100:100:100', '4:16:25 AM');
    > 21 |     expect(result).toBe('[(4, 16, 24), (4, 16, 25)]');
         |                    ^
      22 |   });
      23 |
      24 |   test('if all values are invalid, an empty list is returned', function () {

      at Object.toBe (src/problem-06.test.js:21:20)

  ● Problem 6 - formatTimes() › if all values are invalid, an empty list is returned

    expect(received).toBe(expected) // Object.is equality

    Expected: "[]"
    Received: undefined

      24 |   test('if all values are invalid, an empty list is returned', function () {
      25 |     let result = formatTimes('60:60:60', '100:100:100');
    > 26 |     expect(result).toBe('[]');
         |                    ^
      27 |   });
      28 | });
      29 |

      at Object.toBe (src/problem-06.test.js:26:20)

PASS src/problem-00.test.js
PASS src/problem-07.test.js

Test Suites: 7 failed, 2 passed, 9 total
Tests:       43 failed, 22 passed, 65 total
Snapshots:   0 total
Time:        2.129 s
Ran all test suites.
